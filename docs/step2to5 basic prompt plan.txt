좋아요. **목표는 “1차 완주(End‑to‑End) 성공률 99%+”**입니다.
따라서 2~5단계를 파싱이 쉬운 라인 기반(K/V) 포맷으로 전면 단순화하고, 고정값(브랜드/플랫폼 토큰)은 서버에서 잠그는 전략으로 설계합니다. 스키마·중첩 JSON을 당분간 쓰지 않고, 마커 + 한 줄 한 의미 규칙으로 최소 파싱만 합니다.

⸻

전체 개발 가이드라인(핵심 원칙)
	1.	고정은 서버, 가변은 모델
	•	서버가 잠그는 값: viewport/safeArea/grid/spacing/radius/elevation/zIndex, text/background 색, heading/body 폰트.
	•	모델이 생성하는 값: mood&tone(4개 형용사), primary/secondary/accent, baseSize(18/20pt), componentStyle(≤250자), 레이아웃 섹션 정의(간단 규격), 컴포넌트/이미지 선언(라인 단위).
	2.	출력 형식은 ‘마커 + 라인 기반 K/V’만
	•	예: KEY=VALUE 또는 ITEM,field1=value1,field2=value2
	•	콤마는 구분자, 값 내부 콤마가 필요하면 전각 쉼표(，) 사용 지시.
	3.	마커는 반드시 단독 줄
	•	BEGIN_XXX … END_XXX
	•	블록 외 텍스트 금지(프롬프트로 강제).
	•	파서는 마커 사이 본문만 읽고, 빈줄/공백/모르는 라인 무시.
	4.	성공 우선 품질 게이트(Phase‑1)
	•	Step2: 필수 키 존재, HEX 형식, baseSize 정수, mood 4개 → 나머지 경고.
	•	Step3: 섹션 라인 개수/역할 존재, 모드 고정, 값 파싱 가능 → 자세한 기하 검증 생략.
	•	Step4: 컴포넌트 타입/섹션 참조 유효, 이미지 ≤2, 파일명 규칙 → 겹침·zIndex는 이후 단계.
	5.	모델 파라미터(4o)
	•	temperature=0, top_p=1, stop=[“END_S2”,“END_S3”,“END_S4”](해당 단계용), max_tokens 충분히.
	•	한국어 지시 + 예시 포함, “마커 외 텍스트 금지” 2회 반복.
	6.	폴백/보정(coerce)
	•	누락/오류 값은 서버가 안전한 디폴트로 보충.
	•	HEX 소문자/3자리 등은 정규화(#ABC → #AABBCC).

⸻

Step 1 — 기본 정보 및 프로젝트 설정 (현재 구현 분석)

현재 Step1BasicInfo 컴포넌트는 다음을 수행:

1) 자동 저장 시스템 완전 구현
   - initialData → 컴포넌트 상태 동기화 (한 번만 실행)
   - onDataChange로 실시간 데이터 변경 알림 (0.5초 디바운스)
   - 중복 변경 방지를 위한 해시 기반 변경 감지
   - 새로고침 시 데이터 보존 기능

2) UI/UX 특징
   - 3섹션 레이아웃: 기본정보(1/3) + 레이아웃(1/3) + 생성모드(1/3)
   - 가로 스크롤 페이지 구성 카드 (마우스 휠 가로 스크롤 지원)
   - 애니메이션과 스크롤 최적화 (framer-motion)
   - 스크롤형/고정형 레이아웃 선택 (이미지 기반 라디오)
   - AI향상/제한 모드 선택 (contentMode)

3) 데이터 구조 (출력 계약)
   - projectTitle: string (필수)
   - targetAudience: string (필수)
   - pages: PageInfo[] (최소 1개, 동적 추가/제거)
   - layoutMode: 'scrollable' | 'fixed'
   - contentMode: 'enhanced' | 'restricted' (원래 'original' 대신)
   - suggestions: string[] | undefined

4) 검증 및 테스트
   - 필수 필드 검증 (제목, 대상학습자, 최소 1페이지)
   - 테스트 모드 지원 (목업 데이터 자동 입력)
   - 에러 상태 UI 표시

입력 계약 JSON(서버)

{
  "projectData": {
    "id": "project_timestamp",
    "projectTitle": "프로젝트명",
    "targetAudience": "대상 학습자",
    "layoutMode": "scrollable",  // or "fixed"
    "contentMode": "enhanced",   // or "restricted" (현재 구현)
    "pages": [
      {"id":"1","pageNumber":1,"topic":"주제","description":"설명"}
    ],
    "suggestions": ["추가 제안사항"] | undefined,
    "createdAt": "2025-01-01T00:00:00.000Z"
  }
}

개선사항: contentMode 값이 실제 구현과 다름 ('original' → 'restricted')

⸻

Step 2 — 비주얼 아이덴티티 (현재 구현 분석 및 계획)

현재 Step2VisualIdentity 컴포넌트는 다음을 수행:

1) 현재 구현 특징
   - OpenAI GPT-4 기반 비주얼 아이덴티티 생성
   - JSON 구조화된 출력 사용 (Structured Output)
   - 자동 저장 시스템 구현 (onDataChange, 해시 기반 변경 감지)
   - 자동 생성 (Step1에서 진입 시) + 수동 재생성 지원
   - 생성 상태를 부모에게 전달 (onGeneratingChange)

2) 현재 출력 구조 (JSON 기반)
   - visualIdentity.moodAndTone: string[] (4개 형용사)
   - visualIdentity.colorPalette: {primary, secondary, accent, text, background}
   - visualIdentity.typography: {headingFont, bodyFont, baseSize}
   - visualIdentity.componentStyle: string
   - designTokens: 고정 토큰 셋

3) 향후 개선 계획 (라인 기반 포맷으로 전환)

입력:
	•	Step1 JSON(서버가 프롬프트에 그대로 삽입)

프롬프트（gpt‑4o용, 라인 포맷）

[ROLE] 당신은 교육용 VI 전문가입니다.
[CONTEXT] 다음 프로젝트 계약을 참고하세요.
{{S1_JSON}}

[GOAL] 아래 마커 사이에 "라인 기반 K/V"만 출력하세요. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=vi.v1
- 다음 줄: MOOD=형용사1,형용사2,형용사3,형용사4   // 쉼표로 4개, 공백 없이
- 다음 줄: COLOR_PRIMARY=#RRGGBB
- 다음 줄: COLOR_SECONDARY=#RRGGBB
- 다음 줄: COLOR_ACCENT=#RRGGBB
- 다음 줄: BASE_SIZE_PT=18  또는 20  // 정수만
- 다음 줄: COMPONENT_STYLE=250자 이내 한국어 설명. 쉼표가 필요하면 전각 쉼표(，)를 사용

[HARD RULES]
- text/background, 폰트는 출력 금지(서버가 고정).
- HEX는 # + 6자리(대소문자 무관).
- BASE_SIZE_PT는 18 또는 20만 허용(고정폭/스크롤 권고에 따름).
- 마커 밖 어떤 문장도 쓰지 마세요.

BEGIN_S2
VERSION=vi.v1
...여기에 결과...
END_S2

서버 수신 포맷(예시)

BEGIN_S2
VERSION=vi.v1
MOOD=명료,친근,탐구,안정
COLOR_PRIMARY=#004D99
COLOR_SECONDARY=#E9F4FF
COLOR_ACCENT=#FFCC00
BASE_SIZE_PT=20
COMPONENT_STYLE=라운드 20–28px와 낮은 그림자，정보를 칩으로 층위화하고 본문 가독성을 우선
END_S2

서버 병합(잠금값 주입)

const BRAND_LOCKS = {
  text: "#0F172A",
  background: "#FFFFFF",
  headingFont: "Pretendard",
  bodyFont: "Noto Sans KR"
};
const TOKENS_FIXED = { /* viewport/safeArea/grid/spacing/radius/elevation/zIndex */ };

function assembleStep2(finalKV, layoutMode){
  return {
    visualIdentity: {
      moodAndTone: finalKV.MOOD.split(','),
      colorPalette: {
        primary: finalKV.COLOR_PRIMARY,
        secondary: finalKV.COLOR_SECONDARY,
        accent: finalKV.COLOR_ACCENT,
        text: BRAND_LOCKS.text,
        background: BRAND_LOCKS.background
      },
      typography: {
        headingFont: BRAND_LOCKS.headingFont,
        bodyFont: BRAND_LOCKS.bodyFont,
        baseSize: `${finalKV.BASE_SIZE_PT}pt`
      },
      componentStyle: finalKV.COMPONENT_STYLE
    },
    designTokens: layoutMode==='fixed'? FIXED_PRESET : SCROLL_PRESET
  };
}

기대 효과
	•	JSON 파싱 불필요(라인 정규식만).
	•	고정 토큰/폰트/텍스트색은 서버 잠금 → 검증 실패 근본 해소.
	•	현재 Structured Output에서 라인 기반으로 전환 시 파싱 안정성 99%+ 달성

⸻

Step 3 — 레이아웃 와이어프레임(간단 선언)

1) 입력
	•	Step1 계약, Step2 최종 VI+Tokens(서버 병합 결과)

2) 프롬프트（gpt‑4o, 라인 포맷）

[ROLE] 당신은 교육용 레이아웃 와이어프레임 전문가입니다.
[CONTEXT] 프로젝트/토큰(고정)은 참고만 하세요. 픽셀 좌표는 최소화합니다.
{{S1_JSON}}
{{S2_VI_TOKENS_SUMMARY}}

[GOAL] 마커 사이에 라인 기반 선언만 출력. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=wire.v1
- 다음 줄: VIEWPORT_MODE=scrollable|fixed
- 다음 줄: FLOW=A:intro|B:keyMessage|C:content|D:compare|E:bridge
- 다음 줄들: SECTION, id=secA, role=intro, grid=1-12, height=auto, gapBelow=64
             SECTION, id=secB, role=keyMessage, grid=2-11, height=auto, gapBelow=64
             SECTION, id=secC, role=content, grid=8+4, height=auto, gapBelow=96
             ... 최소 A~E 5개 섹션

[NOTES]
- grid는 두 형식 허용: "1-12"(단일 열폭) 또는 "8+4"(좌우 분할).
- height는 보통 auto. fixed 모드라면 마지막 섹션까지 합이 1000px 안쪽이 되도록 높이를 줄여도 좋음.
- 좌표는 요구하지 않습니다. 구현은 CSS Grid로 합니다.

BEGIN_S3
VERSION=wire.v1
...여기에 결과...
END_S3

3) 서버 수신 예시

BEGIN_S3
VERSION=wire.v1
VIEWPORT_MODE=scrollable
FLOW=A:intro|B:keyMessage|C:content|D:compare|E:bridge
SECTION, id=secA, role=intro, grid=1-12, height=auto, gapBelow=64
SECTION, id=secB, role=keyMessage, grid=2-11, height=auto, gapBelow=64
SECTION, id=secC, role=content, grid=8+4, height=auto, gapBelow=96
SECTION, id=secD, role=compare, grid=1-12, height=auto, gapBelow=64
SECTION, id=secE, role=bridge, grid=2-11, height=auto, gapBelow=80
END_S3

4) 서버 처리
	•	FLOW를 배열로 분해.
	•	SECTION 라인을 파싱해 role ↔ id 매핑과 grid 패턴만 저장.
	•	숫자 검증 최소화(추후 강화).

5) 기대 효과
	•	숫자·좌표 파싱 없이도 그리드 배치 정보 확보.
	•	실패율 거의 0.

⸻

Step 4 — 컴포넌트/이미지 선언(간단 ND‑Lines)

1) 입력
	•	Step1, Step2(병합), Step3(와이어)

2) 프롬프트（gpt‑4o, 라인 포맷）

[ROLE] 당신은 교육 UI 컴포넌트 설계 전문가입니다.
[CONTEXT] 섹션/그리드 정보만을 기반으로 "컴포넌트/이미지 라인"을 선언하세요.
- 이미지: 학습 필수 0~2장(파일명 1.png, 2.png). alt/caption은 80자 이내.

{{S1_JSON}}
{{S2_SUMMARY}}
{{S3_SUMMARY}}

[GOAL] 마커 사이에 라인 기반 선언만 출력. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=cmp.v1
- 컴포넌트 라인(여러 줄):
  COMP, id=secA-title, type=heading, variant=H1, section=secA, role=intro, mode={{contentMode}}, text="페이지 제목"
  COMP, id=secB-key, type=card, variant=none, section=secB, role=keyMessage, mode={{contentMode}}, text="원문 핵심 한 줄 배치"
  COMP, id=secC-left, type=paragraph, variant=Body, section=secC, role=content, gridSpan=left, mode={{contentMode}}, text="원문 개념 전개 문단"
  COMP, id=secC-right, type=image, variant=none, section=secC, role=content, gridSpan=right, src=1.png
- 이미지 라인(최대 2줄):
  IMG, filename=1.png, purpose=diagram, section=secC, place=right, width=520, height=320, alt="...", caption="..."
  IMG, filename=2.png, purpose=comparison, section=secD, place=center, width=600, height=320, alt="...", caption="..."

[RULES]
- gridSpan은 8+4 섹션일 때 left/right를 사용. 1-12 섹션이면 생략 가능.
- mode=restricted일 때 text는 "원문 ○○문단 배치" 같은 배치 지시문으로만.
- 파일명은 1.png → 2.png 순서. 2장을 넘기지 마세요.

BEGIN_S4
VERSION=cmp.v1
...여기에 결과...
END_S4

3) 서버 수신 예시

BEGIN_S4
VERSION=cmp.v1
COMP, id=secA-title, type=heading, variant=H1, section=secA, role=intro, mode=enhanced, text="물의 순환이란 무엇일까?"
COMP, id=secB-key, type=card, variant=none, section=secB, role=keyMessage, mode=restricted, text="원문 핵심 한 줄 배치"
COMP, id=secC-left, type=paragraph, variant=Body, section=secC, role=content, gridSpan=left, mode=restricted, text="원문 개념 전개 문단"
COMP, id=secC-right, type=image, variant=none, section=secC, role=content, gridSpan=right, src=1.png
IMG, filename=1.png, purpose=diagram, section=secC, place=right, width=520, height=320, alt="증발·응결·강수·유출 개념도", caption="물의 순환 개념도"
END_S4

4) 서버 처리
	•	COMP 라인 파싱 → 타입/변형/섹션/역할/텍스트/이미지 참조만 수집.
	•	IMG 라인 파싱 → 파일명 규칙/장수 제한/alt·caption 길이 확인.
	•	좌표/픽셀 배치는 Step5에서 CSS Grid 템플릿으로 계산(grid=1‑12 또는 8+4 기반).

5) 기대 효과
	•	JSON 불요, 간단 정규식만으로 안정 파싱.
	•	contentMode 분기(원본/보강)도 라인에서 바로 반영.

⸻

Step 5 — 최종 산출(“클로드 코드” 프롬프트 조립, AI 호출 불필요)

1) 입력
	•	Step2(병합 완료 VI+Tokens), Step3(와이어 라인), Step4(컴포넌트/이미지 라인)

2) 서버가 프롬프트 문자열 조립 (Claude로 전달)

구성: System + Context(JSON) + Task
	•	System: “코드만 출력(HTML/CSS/JS 순), WCAG 대비, 포커스, 네비 금지, 외부 CDN 금지”
	•	Context JSON: 서버가 만든 단일 JSON(라벨/토큰/섹션/컴포넌트/이미지)
	•	Task: “CSS Grid로 grid=1‑12/8+4를 구현, safeArea 패딩, z-index 규칙(image<card<text), mode=original은 ‘배치 지시문’을 그대로 텍스트로, enhanced는 1–2문장 보강” 등

예시(요지)

[CLAUDE_SYSTEM]
You are an expert front-end engineer for educational content.
Output only three code blocks in this order: (1) index.html (2) styles.css (3) scripts.js if needed.
No explanations outside code blocks. No navigation or external assets.

[CLAUDE_CONTEXT_JSON]
{
  "projectTitle": "...",
  "targetAudience": "...",
  "layoutMode": "scrollable",
  "contentMode": "restricted",
  "visualIdentity": { ...서버 병합 결과... },
  "designTokens": { ...서버 프리셋... },
  "wireframe": { "flow":["A:intro","B:keyMessage","C:content","D:compare","E:bridge"], "sections":[{"id":"secA","role":"intro","grid":"1-12","gapBelow":64}, ...] },
  "components":[ { "id":"secA-title","type":"heading","variant":"H1","section":"secA","role":"intro","mode":"enhanced","text":"..."}, ... ],
  "images":[ {"filename":"1.png","purpose":"diagram","section":"secC","place":"right","width":520,"height":320,"alt":"...","caption":"..."} ]
}

[CLAUDE_TASK]
- Page width is 1600px. If layoutMode is fixed, height is 1000px with overflow hidden. If scrollable, vertical scroll is allowed.
- Implement CSS Grid: 12 columns; for "8+4" sections, render two columns (8fr/4fr). For "1-12", full width.
- Apply safeArea paddings (top 80px, right 100px, bottom 120px, left 100px).
- Use CSS variables from visualIdentity/designTokens for colors/typography/radius/elevation.
- Images use src="assets/images/{filename}" with alt and caption below (18pt).
- contentMode=restricted: keep provided text as placement instructions (do not invent). contentMode=enhanced: you may add up to 2 sentences for clarity.
- Respect contrast (body ≥ 7:1, emphasis ≥ 4.5:1) and focus outline 2px with accent color.
- No navigation/links/buttons. Semantic HTML5 only.

여기서 AI 호출은 Claude만. OpenAI 쪽 파싱은 없음 → 엔드‑투‑엔드 실패 지점 제거.

⸻

운영 체크리스트(Phase‑1)
	•	Step2 프롬프트 라인 포맷 적용, 서버 병합/잠금 로직 도입
	•	Step3 와이어 라인 파서 도입(간단 정규식)
	•	Step4 컴포넌트/이미지 라인 파서 도입(간단 정규식)
	•	Step5 Claude Prompt Pack 조립 함수 구현(코드만 출력 강제)
	•	간단 품질 게이트: 필수 라인 존재/형식만 검사(나머지 경고)
	•	공통 파서:
	•	extractBetween(text, "BEGIN_X", "END_X")
	•	parseKV(line) / parseCSVKVs(line)
	•	전각쉼표 → 반각쉼표 치환, 전각콜론 처리, 대소문자 정규화
	•	HEX 정규화(#abc → #AABBCC)

⸻

각 단계별 “전달 방식” 요약

단계	입력	모델	출력 마커	라인 포맷
2	Step1 JSON	gpt‑4o	BEGIN_S2 … END_S2	KEY=VALUE 6줄
3	Step1+2 요약	gpt‑4o	BEGIN_S3 … END_S3	VERSION/VIEWPORT_MODE/FLOW/SECTION…
4	Step1+2+3 요약	gpt‑4o	BEGIN_S4 … END_S4	COMP… , IMG… ND‑Lines
5	2~4 결과	(서버→Claude)	(없음)	Prompt Pack(코드만 출력)


⸻

왜 이 설계가 “지금 당장 완주”에 유리한가?
	•	중첩 JSON 제거 → 문자열 마커 + 라인 기반 초간단 파싱
	•	고정 토큰 서버 잠금 → LLM이 바꿀 여지 제거 → 검증 실패 근본 해소
	•	그리드 배치 추상화(1‑12, 8+4) → 좌표 숫자 파싱/충돌 검증을 당분간 생략
	•	최종 코드는 Claude 전담 → OpenAI 단계에서 파싱 실패 가능성 0에 수렴

⸻
