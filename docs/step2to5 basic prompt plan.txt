좋아요. **목표는 “1차 완주(End‑to‑End) 성공률 99%+”**입니다.
따라서 2~5단계를 파싱이 쉬운 라인 기반(K/V) 포맷으로 전면 단순화하고, 고정값(브랜드/플랫폼 토큰)은 서버에서 잠그는 전략으로 설계합니다. 스키마·중첩 JSON을 당분간 쓰지 않고, 마커 + 한 줄 한 의미 규칙으로 최소 파싱만 합니다.

⸻

전체 개발 가이드라인(핵심 원칙)
	1.	고정은 서버, 가변은 모델
	•	서버가 잠그는 값: viewport/safeArea/grid/spacing/radius/elevation/zIndex, text/background 색, heading/body 폰트.
	•	모델이 생성하는 값: mood&tone(4개 형용사), primary/secondary/accent, baseSize(18/20pt), componentStyle(≤250자), 레이아웃 섹션 정의(간단 규격), 컴포넌트/이미지 선언(라인 단위).
	2.	출력 형식은 ‘마커 + 라인 기반 K/V’만
	•	예: KEY=VALUE 또는 ITEM,field1=value1,field2=value2
	•	콤마는 구분자, 값 내부 콤마가 필요하면 전각 쉼표(，) 사용 지시.
	3.	마커는 반드시 단독 줄
	•	BEGIN_XXX … END_XXX
	•	블록 외 텍스트 금지(프롬프트로 강제).
	•	파서는 마커 사이 본문만 읽고, 빈줄/공백/모르는 라인 무시.
	4.	성공 우선 품질 게이트(Phase‑1)
	•	Step2: 필수 키 존재, HEX 형식, baseSize 정수, mood 4개 → 나머지 경고.
	•	Step3: 섹션 라인 개수/역할 존재, 모드 고정, 값 파싱 가능 → 자세한 기하 검증 생략.
	•	Step4: 컴포넌트 타입/섹션 참조 유효, 이미지 ≤2, 파일명 규칙 → 겹침·zIndex는 이후 단계.
	5.	모델 파라미터(4o)
	•	temperature=0, top_p=1, stop=[“END_S2”,“END_S3”,“END_S4”](해당 단계용), max_tokens 충분히.
	•	한국어 지시 + 예시 포함, “마커 외 텍스트 금지” 2회 반복.
	6.	폴백/보정(coerce)
	•	누락/오류 값은 서버가 안전한 디폴트로 보충.
	•	HEX 소문자/3자리 등은 정규화(#ABC → #AABBCC).

⸻

Step 1 — 기본 정보 및 프로젝트 설정 (현재 구현 분석)

현재 Step1BasicInfo 컴포넌트는 다음을 수행:

1) 자동 저장 시스템 완전 구현
   - initialData → 컴포넌트 상태 동기화 (한 번만 실행)
   - onDataChange로 실시간 데이터 변경 알림 (0.5초 디바운스)
   - 중복 변경 방지를 위한 해시 기반 변경 감지
   - 새로고침 시 데이터 보존 기능

2) UI/UX 특징
   - 3섹션 레이아웃: 기본정보(1/3) + 레이아웃(1/3) + 생성모드(1/3)
   - 가로 스크롤 페이지 구성 카드 (마우스 휠 가로 스크롤 지원)
   - 애니메이션과 스크롤 최적화 (framer-motion)
   - 스크롤형/고정형 레이아웃 선택 (이미지 기반 라디오)
   - AI향상/제한 모드 선택 (contentMode)

3) 데이터 구조 (출력 계약)
   - projectTitle: string (필수)
   - targetAudience: string (필수)
   - pages: PageInfo[] (최소 1개, 동적 추가/제거)
   - layoutMode: 'scrollable' | 'fixed'
   - contentMode: 'enhanced' | 'restricted' (원래 'original' 대신)
   - suggestions: string[] | undefined

4) 검증 및 테스트
   - 필수 필드 검증 (제목, 대상학습자, 최소 1페이지)
   - 테스트 모드 지원 (목업 데이터 자동 입력)
   - 에러 상태 UI 표시

입력 계약 JSON(서버)

{
  "projectData": {
    "id": "project_timestamp",
    "projectTitle": "프로젝트명",
    "targetAudience": "대상 학습자",
    "layoutMode": "scrollable",  // or "fixed"
    "contentMode": "enhanced",   // or "restricted" (현재 구현)
    "pages": [
      {"id":"1","pageNumber":1,"topic":"주제","description":"설명"}
    ],
    "suggestions": ["추가 제안사항"] | undefined,
    "createdAt": "2025-01-01T00:00:00.000Z"
  }
}

개선사항: contentMode 값이 실제 구현과 다름 ('original' → 'restricted')

⸻

Step 2 — 비주얼 아이덴티티 (현재 구현 분석 및 계획)

현재 Step2VisualIdentity 컴포넌트는 다음을 수행:

1) 현재 구현 특징
   - OpenAI GPT-4 기반 비주얼 아이덴티티 생성
   - JSON 구조화된 출력 사용 (Structured Output)
   - 자동 저장 시스템 구현 (onDataChange, 해시 기반 변경 감지)
   - 자동 생성 (Step1에서 진입 시) + 수동 재생성 지원
   - 생성 상태를 부모에게 전달 (onGeneratingChange)

2) 현재 출력 구조 (JSON 기반)
   - visualIdentity.moodAndTone: string[] (4개 형용사)
   - visualIdentity.colorPalette: {primary, secondary, accent, text, background}
   - visualIdentity.typography: {headingFont, bodyFont, baseSize}
   - visualIdentity.componentStyle: string
   - designTokens: 고정 토큰 셋

3) 향후 개선 계획 (라인 기반 포맷으로 전환)

입력:
	•	Step1 JSON(서버가 프롬프트에 그대로 삽입)

프롬프트（gpt‑4o용, 라인 포맷）

[ROLE] 당신은 교육용 VI 전문가입니다.
[CONTEXT] 다음 프로젝트 계약을 참고하세요.
{{S1_JSON}}

[GOAL] 아래 마커 사이에 "라인 기반 K/V"만 출력하세요. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=vi.v1
- 다음 줄: MOOD=형용사1,형용사2,형용사3,형용사4   // 쉼표로 4개, 공백 없이
- 다음 줄: COLOR_PRIMARY=#RRGGBB
- 다음 줄: COLOR_SECONDARY=#RRGGBB
- 다음 줄: COLOR_ACCENT=#RRGGBB
- 다음 줄: BASE_SIZE_PT=18  또는 20  // 정수만
- 다음 줄: COMPONENT_STYLE=250자 이내 한국어 설명. 쉼표가 필요하면 전각 쉼표(，)를 사용

[HARD RULES]
- text/background, 폰트는 출력 금지(서버가 고정).
- HEX는 # + 6자리(대소문자 무관).
- BASE_SIZE_PT는 18 또는 20만 허용(고정폭/스크롤 권고에 따름).
- 마커 밖 어떤 문장도 쓰지 마세요.

BEGIN_S2
VERSION=vi.v1
...여기에 결과...
END_S2

서버 수신 포맷(예시)

BEGIN_S2
VERSION=vi.v1
MOOD=명료,친근,탐구,안정
COLOR_PRIMARY=#004D99
COLOR_SECONDARY=#E9F4FF
COLOR_ACCENT=#FFCC00
BASE_SIZE_PT=20
COMPONENT_STYLE=라운드 20–28px와 낮은 그림자，정보를 칩으로 층위화하고 본문 가독성을 우선
END_S2

서버 병합(잠금값 주입)

const BRAND_LOCKS = {
  text: "#0F172A",
  background: "#FFFFFF",
  headingFont: "Pretendard",
  bodyFont: "Noto Sans KR"
};
const TOKENS_FIXED = { /* viewport/safeArea/grid/spacing/radius/elevation/zIndex */ };

function assembleStep2(finalKV, layoutMode){
  return {
    visualIdentity: {
      moodAndTone: finalKV.MOOD.split(','),
      colorPalette: {
        primary: finalKV.COLOR_PRIMARY,
        secondary: finalKV.COLOR_SECONDARY,
        accent: finalKV.COLOR_ACCENT,
        text: BRAND_LOCKS.text,
        background: BRAND_LOCKS.background
      },
      typography: {
        headingFont: BRAND_LOCKS.headingFont,
        bodyFont: BRAND_LOCKS.bodyFont,
        baseSize: `${finalKV.BASE_SIZE_PT}pt`
      },
      componentStyle: finalKV.COMPONENT_STYLE
    },
    designTokens: layoutMode==='fixed'? FIXED_PRESET : SCROLL_PRESET
  };
}

기대 효과
	•	JSON 파싱 불필요(라인 정규식만).
	•	고정 토큰/폰트/텍스트색은 서버 잠금 → 검증 실패 근본 해소.
	•	현재 Structured Output에서 라인 기반으로 전환 시 파싱 안정성 99%+ 달성

⸻

Step 3 — 레이아웃 와이어프레임 (현재 구현 분석 및 계획)

현재 Step3LayoutWireframe 컴포넌트와 서비스 분석:

## 1) 현재 AI 동작 분석

### AI 요청 및 전달 데이터:
- **병렬 처리**: 모든 페이지를 Promise.all로 동시 생성 (성능 최적화)
- **요청 형식**: 일반 completion 요청 (Structured Output 미사용)
- **전달 데이터**:
  - projectData: Step1에서 받은 프로젝트 정보
  - visualIdentity: Step2에서 생성된 VI 정보
  - designTokens: Step2에서 병합된 토큰
  - 페이지별 맥락 정보 (이전/다음 페이지 연결성)

### 현재 프롬프트 구조 (강화된 제약):
- 교육적 맥락과 페이지 흐름 정보 포함
- contentMode별 생성 가이드라인 (restricted vs enhanced)
- layoutMode별 레이아웃 제약사항 (scrollable vs fixed)
- **두 블록 형식 사용**: BEGIN_S3_LAYOUT + BEGIN_S3_SLOTS
- **강화된 제약사항**:
  - 마커 밖 텍스트 금지 (2회 반복 강조)
  - 코드 펜스, HTML 태그, 리스트/표 금지
  - 한 줄에 하나의 레코드만 출력 강제

### 생성 데이터:
- **두 블록 응답**: S3_LAYOUT (섹션 정의) + S3_SLOTS (슬롯 정의)
- 페이지별 독립 와이어프레임 생성
- 창의 토큰과 디자인 가이드라인 적용

## 2) 파싱 시스템 분석

### 정규화 처리:
- **normalizeResponse()**: CRLF→LF, 전각문자 정규화, HTML 태그 제거
- 스마트 따옴표, 전각 콜론 처리
- 단위 대문자 정규화 (PX→px, PT→pt)

### 두 블록 파싱 (강화된 안정성):
- **extractWireframeFromResponse()**: 정규식으로 두 블록 추출
- **parseNewWireframeFormat()**: 라인 기반 KEY=VALUE 파싱
- **splitLinesSafely()**: 한 줄 = 한 레코드 강제 분리 가드
- **parseRecordLine()**: 정규식 기반 CSV 레코드 파싱 (따옴표 처리 개선)
- **normalizeGapBelow()**: 64/80/96 중 가장 가까운 값으로 스냅
- **SECTION 정책 강제**: height=auto 고정, grid 허용값 검증 (1-12,8+4,2-11,3-10)

### 레거시 지원:
- 기존 단일 블록 형식도 파싱 가능
- **parseWireframeLines()**: 이전 버전 호환성 유지

## 3) 예외 처리 분석

### 강력한 품질 게이트:
- **validateStep3Result()**: 포괄적 데이터 검증
  - VERSION, VIEWPORT_MODE, FLOW 패턴 검증
  - 최소 5개 섹션 확인
  - IMG_BUDGET 초과 검증
  - 고아 슬롯 탐지
  - 8+4 섹션의 gridSpan 검증
  - SUMMARY 수치 일치성 검증

### 자동 보정 시스템:
- **applyCorrections()**: 검증 실패 시 자동 복구
  - 누락 섹션 자동 추가 (스켈레톤)
  - 초과 이미지 슬롯 제거
  - gridSpan 자동 배정
  - 고아 슬롯 제거
  - 디폴트 값으로 보정

### 에러 처리 및 폴백 시스템:
- **페이지별 독립 에러 처리**: 병렬 처리 중 일부 실패 시 전체 실패
- **파싱 실패 폴백**:
  - extractWireframeFromResponse() 실패 시 → synthesizeMinimalWireframe() 자동 생성
  - convertNewWireframeToDescription() 실패 시 → createPlainDescriptionFallback() 제공
- **이중 안전망**: AI 응답 파싱 실패해도 최소 와이어프레임 보장
- **computePageFlow()**: 페이지 위치별 자동 FLOW 계산 (A:intro, B:keyMessage, E:bridge)

## 4) 프론트엔드 표시 내용

### 자동 저장 시스템:
- initialData 동기화 (한 번만 실행)
- 해시 기반 변경 감지 및 실시간 onDataChange
- 생성 상태 부모 전달 (onGeneratingChange)

### 로딩 상태:
- 병렬 생성에 특화된 로딩 UI
- 다중 페이지 처리 상태 표시
- 병렬 처리 성능 강조 메시지

### 결과 표시:
- **페이지별 카드 형태**: 페이지 번호, 제목, 생성 시간
- **AI 응답 원본**: layoutDescription (읽기 쉬운 산문 형태)
- **파싱된 데이터**: 접이식 디테일로 구조화된 정보
  - Page Style, Sections, Slots, Summary 분리 표시
  - 각 섹션/슬롯의 속성 테이블 형태로 표시
- **파싱 실패 표시**: 원본 응답만 보여주고 상태 안내

### 네비게이션:
- 이전/다음 단계 버튼
- 재생성 기능
- 완료 시 Step4 전환

## 5) 향후 계획 (라인 기반 단순화)

입력:
	•	Step1 계약, Step2 최종 VI+Tokens(서버 병합 결과)

프롬프트（gpt‑4o, 라인 포맷）

[ROLE] 당신은 교육용 레이아웃 와이어프레임 전문가입니다.
[CONTEXT] 프로젝트/토큰(고정)은 참고만 하세요. 픽셀 좌표는 최소화합니다.
{{S1_JSON}}
{{S2_VI_TOKENS_SUMMARY}}

[GOAL] 마커 사이에 라인 기반 선언만 출력. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=wire.v1
- 다음 줄: VIEWPORT_MODE=scrollable|fixed
- 다음 줄: FLOW=A:intro|B:keyMessage|C:content|D:compare|E:bridge
- 다음 줄들: SECTION, id=secA, role=intro, grid=1-12, height=auto, gapBelow=64
             SECTION, id=secB, role=keyMessage, grid=2-11, height=auto, gapBelow=64
             SECTION, id=secC, role=content, grid=8+4, height=auto, gapBelow=96
             ... 최소 A~E 5개 섹션

[NOTES]
- grid는 두 형식 허용: "1-12"(단일 열폭) 또는 "8+4"(좌우 분할).
- height는 보통 auto. fixed 모드라면 마지막 섹션까지 합이 1000px 안쪽이 되도록 높이를 줄여도 좋음.
- 좌표는 요구하지 않습니다. 구현은 CSS Grid로 합니다.

BEGIN_S3
VERSION=wire.v1
...여기에 결과...
END_S3

서버 수신 예시

BEGIN_S3
VERSION=wire.v1
VIEWPORT_MODE=scrollable
FLOW=A:intro|B:keyMessage|C:content|D:compare|E:bridge
SECTION, id=secA, role=intro, grid=1-12, height=auto, gapBelow=64
SECTION, id=secB, role=keyMessage, grid=2-11, height=auto, gapBelow=64
SECTION, id=secC, role=content, grid=8+4, height=auto, gapBelow=96
SECTION, id=secD, role=compare, grid=1-12, height=auto, gapBelow=64
SECTION, id=secE, role=bridge, grid=2-11, height=auto, gapBelow=80
END_S3

서버 처리
	•	FLOW를 배열로 분해.
	•	SECTION 라인을 파싱해 role ↔ id 매핑과 grid 패턴만 저장.
	•	숫자 검증 최소화(추후 강화).

기대 효과
	•	현재 두 블록 방식에서 단일 블록으로 단순화
	•	병렬 처리와 품질 게이트 시스템은 유지
	•	파싱 안정성 99%+ 달성

⸻
