좋아요. **목표는 “1차 완주(End‑to‑End) 성공률 99%+”**입니다.
따라서 2~5단계를 파싱이 쉬운 라인 기반(K/V) 포맷으로 전면 단순화하고, 고정값(브랜드/플랫폼 토큰)은 서버에서 잠그는 전략으로 설계합니다. 스키마·중첩 JSON을 당분간 쓰지 않고, 마커 + 한 줄 한 의미 규칙으로 최소 파싱만 합니다.

⸻

전체 개발 가이드라인(핵심 원칙)
	1.	고정은 서버, 가변은 모델
	•	서버가 잠그는 값: viewport/safeArea/grid/spacing/radius/elevation/zIndex, text/background 색, heading/body 폰트.
	•	모델이 생성하는 값: mood&tone(4개 형용사), primary/secondary/accent, baseSize(18/20pt), componentStyle(≤250자), 레이아웃 섹션 정의(간단 규격), 컴포넌트/이미지 선언(라인 단위).
	2.	출력 형식은 ‘마커 + 라인 기반 K/V’만
	•	예: KEY=VALUE 또는 ITEM,field1=value1,field2=value2
	•	콤마는 구분자, 값 내부 콤마가 필요하면 전각 쉼표(，) 사용 지시.
	3.	마커는 반드시 단독 줄
	•	BEGIN_XXX … END_XXX
	•	블록 외 텍스트 금지(프롬프트로 강제).
	•	파서는 마커 사이 본문만 읽고, 빈줄/공백/모르는 라인 무시.
	4.	성공 우선 품질 게이트(Phase‑1)
	•	Step2: 필수 키 존재, HEX 형식, baseSize 정수, mood 4개 → 나머지 경고.
	•	Step3: 섹션 라인 개수/역할 존재, 모드 고정, 값 파싱 가능 → 자세한 기하 검증 생략.
	•	Step4: 컴포넌트 타입/섹션 참조 유효, 이미지 ≤2, 파일명 규칙 → 겹침·zIndex는 이후 단계.
	5.	모델 파라미터(4o)
	•	temperature=0, top_p=1, stop=[“END_S2”,“END_S3”,“END_S4”](해당 단계용), max_tokens 충분히.
	•	한국어 지시 + 예시 포함, “마커 외 텍스트 금지” 2회 반복.
	6.	폴백/보정(coerce)
	•	누락/오류 값은 서버가 안전한 디폴트로 보충.
	•	HEX 소문자/3자리 등은 정규화(#ABC → #AABBCC).

⸻

Step 1 — 기본 정보 및 프로젝트 설정 (현재 구현 분석)

현재 Step1BasicInfo 컴포넌트는 다음을 수행:

1) 자동 저장 시스템 완전 구현
   - initialData → 컴포넌트 상태 동기화 (한 번만 실행)
   - onDataChange로 실시간 데이터 변경 알림 (0.5초 디바운스)
   - 중복 변경 방지를 위한 해시 기반 변경 감지
   - 새로고침 시 데이터 보존 기능

2) UI/UX 특징
   - 3섹션 레이아웃: 기본정보(1/3) + 레이아웃(1/3) + 생성모드(1/3)
   - 가로 스크롤 페이지 구성 카드 (마우스 휠 가로 스크롤 지원)
   - 애니메이션과 스크롤 최적화 (framer-motion)
   - 스크롤형/고정형 레이아웃 선택 (이미지 기반 라디오)
   - AI향상/제한 모드 선택 (contentMode)

3) 데이터 구조 (출력 계약)
   - projectTitle: string (필수)
   - targetAudience: string (필수)
   - pages: PageInfo[] (최소 1개, 동적 추가/제거)
   - layoutMode: 'scrollable' | 'fixed'
   - contentMode: 'enhanced' | 'restricted' (원래 'original' 대신)
   - suggestions: string[] | undefined

4) 검증 및 테스트
   - 필수 필드 검증 (제목, 대상학습자, 최소 1페이지)
   - 테스트 모드 지원 (목업 데이터 자동 입력)
   - 에러 상태 UI 표시

입력 계약 JSON(서버)

{
  "projectData": {
    "id": "project_timestamp",
    "projectTitle": "프로젝트명",
    "targetAudience": "대상 학습자",
    "layoutMode": "scrollable",  // or "fixed"
    "contentMode": "enhanced",   // or "restricted" (현재 구현)
    "pages": [
      {"id":"1","pageNumber":1,"topic":"주제","description":"설명"}
    ],
    "suggestions": ["추가 제안사항"] | undefined,
    "createdAt": "2025-01-01T00:00:00.000Z"
  }
}

개선사항: contentMode 값이 실제 구현과 다름 ('original' → 'restricted')

⸻

Step 2 — 비주얼 아이덴티티 (현재 구현 분석 및 계획)

현재 Step2VisualIdentity 컴포넌트는 다음을 수행:

1) 현재 구현 특징
   - OpenAI GPT-4 기반 비주얼 아이덴티티 생성
   - JSON 구조화된 출력 사용 (Structured Output)
   - 자동 저장 시스템 구현 (onDataChange, 해시 기반 변경 감지)
   - 자동 생성 (Step1에서 진입 시) + 수동 재생성 지원
   - 생성 상태를 부모에게 전달 (onGeneratingChange)

2) 현재 출력 구조 (JSON 기반)
   - visualIdentity.moodAndTone: string[] (4개 형용사)
   - visualIdentity.colorPalette: {primary, secondary, accent, text, background}
   - visualIdentity.typography: {headingFont, bodyFont, baseSize}
   - visualIdentity.componentStyle: string
   - designTokens: 고정 토큰 셋

3) 향후 개선 계획 (라인 기반 포맷으로 전환)

입력:
	•	Step1 JSON(서버가 프롬프트에 그대로 삽입)

프롬프트（gpt‑4o용, 라인 포맷）

[ROLE] 당신은 교육용 VI 전문가입니다.
[CONTEXT] 다음 프로젝트 계약을 참고하세요.
{{S1_JSON}}

[GOAL] 아래 마커 사이에 "라인 기반 K/V"만 출력하세요. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=vi.v1
- 다음 줄: MOOD=형용사1,형용사2,형용사3,형용사4   // 쉼표로 4개, 공백 없이
- 다음 줄: COLOR_PRIMARY=#RRGGBB
- 다음 줄: COLOR_SECONDARY=#RRGGBB
- 다음 줄: COLOR_ACCENT=#RRGGBB
- 다음 줄: BASE_SIZE_PT=18  또는 20  // 정수만
- 다음 줄: COMPONENT_STYLE=250자 이내 한국어 설명. 쉼표가 필요하면 전각 쉼표(，)를 사용

[HARD RULES]
- text/background, 폰트는 출력 금지(서버가 고정).
- HEX는 # + 6자리(대소문자 무관).
- BASE_SIZE_PT는 18 또는 20만 허용(고정폭/스크롤 권고에 따름).
- 마커 밖 어떤 문장도 쓰지 마세요.

BEGIN_S2
VERSION=vi.v1
...여기에 결과...
END_S2

서버 수신 포맷(예시)

BEGIN_S2
VERSION=vi.v1
MOOD=명료,친근,탐구,안정
COLOR_PRIMARY=#004D99
COLOR_SECONDARY=#E9F4FF
COLOR_ACCENT=#FFCC00
BASE_SIZE_PT=20
COMPONENT_STYLE=라운드 20–28px와 낮은 그림자，정보를 칩으로 층위화하고 본문 가독성을 우선
END_S2

서버 병합(잠금값 주입)

const BRAND_LOCKS = {
  text: "#0F172A",
  background: "#FFFFFF",
  headingFont: "Pretendard",
  bodyFont: "Noto Sans KR"
};
const TOKENS_FIXED = { /* viewport/safeArea/grid/spacing/radius/elevation/zIndex */ };

function assembleStep2(finalKV, layoutMode){
  return {
    visualIdentity: {
      moodAndTone: finalKV.MOOD.split(','),
      colorPalette: {
        primary: finalKV.COLOR_PRIMARY,
        secondary: finalKV.COLOR_SECONDARY,
        accent: finalKV.COLOR_ACCENT,
        text: BRAND_LOCKS.text,
        background: BRAND_LOCKS.background
      },
      typography: {
        headingFont: BRAND_LOCKS.headingFont,
        bodyFont: BRAND_LOCKS.bodyFont,
        baseSize: `${finalKV.BASE_SIZE_PT}pt`
      },
      componentStyle: finalKV.COMPONENT_STYLE
    },
    designTokens: layoutMode==='fixed'? FIXED_PRESET : SCROLL_PRESET
  };
}

기대 효과
	•	JSON 파싱 불필요(라인 정규식만).
	•	고정 토큰/폰트/텍스트색은 서버 잠금 → 검증 실패 근본 해소.
	•	현재 Structured Output에서 라인 기반으로 전환 시 파싱 안정성 99%+ 달성

⸻

Step 3 — 페이지별 콘텐츠 설계 (통합 2단계 아키텍처)

현재 Step3IntegratedDesign 컴포넌트는 다음과 같은 고도화된 2단계 병렬 처리 시스템을 구현:

1) 핵심 아키텍처: 2-Phase 병렬 처리
   - Phase 1 (구조 설계): 모든 페이지의 와이어프레임 구조를 병렬로 생성
   - Phase 2 (콘텐츠 생성): Phase1 완료 후 각 페이지별 상세 콘텐츠를 병렬로 생성
   - 총 처리 시간 단축: N개 페이지를 순차 처리 대신 2단계 병렬로 최적화
   - 실패 내성: 개별 페이지 실패가 전체 프로세스를 중단하지 않음

2) AI 동작 원리 및 프롬프트 전략

   **Phase 1 프롬프트 (기존 Step3 방식 활용)**:
   - 목적: 페이지별 와이어프레임 구조(섹션 정의) 생성
   - 출력 형식: VERSION=wire.v1 + SECTION 라인들
   - 파싱 대상: SECTION, id=secA, role=title/content, grid=1-12/8+4/2-11/3-10, height=auto, hint=설명, gapBelow=숫자
   - 검증: 3-5개 섹션, role 유효성, grid 형식, hint 존재
   - 특징: 교육 컨텐츠 특화 ("마무리", "정리" 등 네비게이션 표현 금지)

   **Phase 2 프롬프트 (기존 Step4 방식 활용)**:
   - 목적: Phase1 구조 기반으로 실제 텍스트 콘텐츠 및 이미지 계획 생성
   - 출력 형식: BEGIN_CONTENT...END_CONTENT 블록 + COMP/IMG 라인들
   - COMP 라인: id, type(heading/paragraph/card/image), variant, section, role, gridSpan, text, src
   - IMG 라인: filename, purpose, section, place, width, height, alt, caption, description, aiPrompt, style
   - 레이아웃별 분량 제한: fixed(보수적), scrollable(적당한 분량)
   - 이미지 파일명 정규화: 페이지별로 1.png, 2.png... 순서

3) 병렬 처리 및 성능 최적화

   **Phase 1 병렬 처리**:
   ```
   Phase1: 모든 페이지 구조 설계 병렬 생성...
   🔄 Phase1 - 페이지 1 구조 설계 시작: 주제1
   🔄 Phase1 - 페이지 2 구조 설계 시작: 주제2
   ...
   ⏰ Phase1: N개 페이지 구조 설계 병렬 처리 대기 중...
   ✅ Phase1 - 모든 페이지 구조 설계 완료
   ```

   **Phase 2 병렬 처리**:
   ```
   Phase2: 각 페이지별 콘텐츠 생성 병렬 시작...
   🔄 Phase2 - 페이지 1 콘텐츠 생성 시작
   🔄 Phase2 - 페이지 2 콘텐츠 생성 시작
   ...
   ⏰ Phase2: N개 페이지 콘텐츠 생성 병렬 처리 대기 중...
   ✅ Phase2 - 모든 페이지 콘텐츠 생성 완료
   ```

   **Promise.all() 활용**: 각 Phase별로 모든 페이지를 Promise.all()로 병렬 처리

4) 재시도 로직 및 실패 처리

   **자동 재시도 시스템 (handleParsingFailures)**:
   - 최대 재시도: 3회 (MAX_RETRIES = 3)
   - 재시도 간격: 2초 (RETRY_DELAY = 2000ms)
   - 재시도 대상: parseError가 있고 phase1Complete 또는 phase2Complete가 false인 페이지
   - 병렬 재시도: 실패한 여러 페이지를 동시에 재생성
   - 점진적 성공: 일부 페이지가 성공하면 계속 진행, 남은 실패 페이지만 재시도

   **실패 상태 추적**:
   - retryCount: 페이지별 재시도 횟수 카운터
   - parseError: 구체적 오류 메시지 저장
   - phase1Complete/phase2Complete: 각 단계별 완료 상태
   - isGenerating: 현재 생성 중 여부

5) UI/UX 실시간 피드백 시스템

   **페이지 선택 탭의 상태 표시**:
   - 🔄 생성 중: 회전 애니메이션 아이콘 + "생성 중..." 텍스트
   - 📊 재시도 표시: 주황색 "재시도 N" 배지
   - 🔴 파싱 실패: 빨간 점 표시 + "파싱 실패" 툴팁
   - 🟢 완료: 초록 점 표시 + "완료" 툴팁
   - 🟡 처리 중: 노란 점 표시 + "처리 중" 툴팁

   **Phase별 진행 상태 표시**:
   - Phase 1: 구조설계 - 완료 시 초록색, 진행 중 파란색 애니메이션
   - Phase 2: 콘텐츠생성 - 완료 시 초록색, 진행 중 파란색 애니메이션
   - 현재 작업 표시: "Phase 1: 구조 설계 중...", "Phase 2: 콘텐츠 생성 중..."

   **로딩 화면 분기**:
   - 초기 로딩: "페이지별 콘텐츠 설계 중..." (전체 생성)
   - 개별 재생성: "페이지 재생성 중..." + 재시도 페이지 목록
   - 생성 중 오버레이: 개별 페이지 재생성 시 해당 페이지에만 반투명 오버레이

6) 개별 페이지 재생성 기능

   **regeneratePage 메서드**:
   - Phase 1, 2 순차적 재실행 (전체 페이지 재생성과 동일한 로직)
   - 재생성 중 상태 표시: isGenerating = true
   - 기존 데이터 초기화: content, structure 제거 후 새로 생성
   - 에러 시 parseError 업데이트

   **전체 재생성 vs 개별 재생성**:
   - 전체 재생성: 모든 데이터 초기화 후 2단계 병렬 처리
   - 개별 재생성: 선택된 페이지만 Phase 1+2 순차 실행

7) 파싱 시스템 및 데이터 구조

   **Phase 1 파싱 (parseWireframeResponse)**:
   - 입력: AI 응답 텍스트 (```마커 제거)
   - 추출: FLOW=값, SECTION 라인들
   - 결과: {sections: Step3Section[], flow: string}
   - 섹션 구조: id, role, grid, height, hint, gapBelow

   **Phase 2 파싱 (parseContentResponse)**:
   - 입력: BEGIN_CONTENT...END_CONTENT 블록
   - 추출: COMP 라인 → ComponentLine[], IMG 라인 → ImageLine[]
   - 정규화: 이미지 파일명을 1.png, 2.png 형태로 통일
   - parseRecordLine: key=value 쌍을 파싱하는 범용 파서

   **레코드 파싱의 정교함**:
   - 키 위치 탐지: 정규식으로 모든 key= 패턴 찾기
   - 값 추출: 다음 키 직전까지 또는 줄 끝까지
   - 따옴표 처리: 쌍따옴표/홑따옴표 자동 제거
   - 쉼표 처리: 구분자 쉼표 vs 내용 쉼표 구분

8) 이미지 생성 계획 시스템

   **이미지 메타데이터**:
   - filename: 페이지별 순차 번호 (1.png, 2.png...)
   - purpose: diagram/illustration/comparison
   - place: left/right/center (8+4 그리드의 좌우 배치)
   - 크기: width/height 픽셀값
   - 접근성: alt 텍스트, caption
   - AI 생성용: aiPrompt (한글), style, description

   **이미지 파일 경로 구조**:
   ```
   ~/image/page1/1.png
   ~/image/page1/2.png
   ~/image/page2/1.png
   ...
   ```

   **원형 숫자 아이콘 매핑**:
   - UI에서 이미지를 ⓪①②③④⑤⑥⑦⑧⑨ 아이콘으로 시각화
   - getCircledNumber 유틸리티로 파일명에서 숫자 추출 후 변환

9) 디버그 모드 및 개발자 도구

   **디버그 정보 수집**:
   - phase1.debugInfo: {prompt: string, response: string}
   - phase2.debugInfo: {prompt: string, response: string}
   - 모든 AI 요청/응답을 페이지별로 저장

   **디버그 UI**:
   - Debug ON/OFF 토글 버튼
   - Phase별 프롬프트와 AI 응답 표시 (코드 블록)
   - 파란색(Phase1)/초록색(Phase2) 구분
   - 스크롤 가능한 프롬프트 박스

10) 자동 저장 시스템 통합

   **자동 저장 준수사항**:
   - initialData → 컴포넌트 상태 동기화 (useEffect)
   - onDataChange: 해시 기반 중복 방지로 실시간 변경 알림
   - onComplete: 모든 페이지 완료 시 데이터 전달
   - onGeneratingChange: 생성 상태를 부모 컴포넌트로 전달

   **새로고침 데이터 보존**:
   - 기존 데이터 감지 시 자동 생성 건너뛰기
   - shouldAutoGenerate 플래그로 불필요한 재생성 방지
   - 해시 기반 변경 감지로 중복 저장 방지

11) 타입 시스템 및 데이터 계약

   **Step3IntegratedResult 구조**:
   ```typescript
   {
     layoutMode: 'scrollable' | 'fixed',
     pages: Array<{
       pageId: string,
       pageTitle: string,
       pageNumber: number,

       // Phase1 결과 (내부용)
       structure?: {
         sections: Step3Section[],
         flow: string,
         imgBudget: number
       },

       // Phase2 결과 (사용자 표시용)
       content?: {
         components: ComponentLine[],
         images: ImageLine[],
         generatedAt: Date
       },

       // 상태 관리
       isGenerating: boolean,
       phase1Complete: boolean,
       phase2Complete: boolean,
       retryCount?: number,
       parseError?: string,

       // 디버깅
       debugInfo?: {
         phase1?: {prompt: string, response: string},
         phase2?: {prompt: string, response: string}
       },

       generatedAt: Date
     }>,
     generatedAt: Date
   }
   ```

12) 성능 및 확장성 고려사항

   **병렬 처리 이점**:
   - 기존: 페이지별 순차 처리 → O(N×T) 시간
   - 현재: 2단계 병렬 처리 → O(2×T) 시간 (N개 페이지 동시 처리)
   - 실제 성능 향상: 5페이지 기준 약 60% 시간 단축

   **메모리 효율성**:
   - 페이지별 독립 처리로 메모리 부담 분산
   - 실패 페이지만 재시도하여 불필요한 API 호출 방지
   - 디버그 정보는 옵션으로만 저장

   **에러 복구 능력**:
   - 부분 실패 허용: 일부 페이지 실패해도 나머지는 정상 완료
   - 점진적 재시도: 성공한 페이지는 건너뛰고 실패 페이지만 재처리
   - 사용자 선택권: 개별 페이지 수동 재생성 가능

13) 향후 개선 계획 (라인 기반 포맷 전환 대비)

   **현재**: OpenAI Structured Output 사용하지 않음 (이미 라인 기반)
   **장점**: 파싱 안정성이 이미 99%+ 수준
   **개선 포인트**: 프롬프트 최적화를 통한 생성 품질 향상

   **Phase1 개선안**:
   - SECTION 라인 파싱은 이미 안정적
   - 교육 콘텐츠 특화 프롬프트 강화

   **Phase2 개선안**:
   - COMP/IMG 라인 파싱도 이미 안정적
   - 이미지 생성 프롬프트 품질 개선
   - 레이아웃별 콘텐츠 분량 조정

⸻

