좋아요. **목표는 “1차 완주(End‑to‑End) 성공률 99%+”**입니다.
따라서 2~5단계를 파싱이 쉬운 라인 기반(K/V) 포맷으로 전면 단순화하고, 고정값(브랜드/플랫폼 토큰)은 서버에서 잠그는 전략으로 설계합니다. 스키마·중첩 JSON을 당분간 쓰지 않고, 마커 + 한 줄 한 의미 규칙으로 최소 파싱만 합니다.

⸻

전체 개발 가이드라인(핵심 원칙)
	1.	고정은 서버, 가변은 모델
	•	서버가 잠그는 값: viewport/safeArea/grid/spacing/radius/elevation/zIndex, text/background 색, heading/body 폰트.
	•	모델이 생성하는 값: mood&tone(4개 형용사), primary/secondary/accent, baseSize(18/20pt), componentStyle(≤250자), 레이아웃 섹션 정의(간단 규격), 컴포넌트/이미지 선언(라인 단위).
	2.	출력 형식은 ‘마커 + 라인 기반 K/V’만
	•	예: KEY=VALUE 또는 ITEM,field1=value1,field2=value2
	•	콤마는 구분자, 값 내부 콤마가 필요하면 전각 쉼표(，) 사용 지시.
	3.	마커는 반드시 단독 줄
	•	BEGIN_XXX … END_XXX
	•	블록 외 텍스트 금지(프롬프트로 강제).
	•	파서는 마커 사이 본문만 읽고, 빈줄/공백/모르는 라인 무시.
	4.	성공 우선 품질 게이트(Phase‑1)
	•	Step2: 필수 키 존재, HEX 형식, baseSize 정수, mood 4개 → 나머지 경고.
	•	Step3: 섹션 라인 개수/역할 존재, 모드 고정, 값 파싱 가능 → 자세한 기하 검증 생략.
	•	Step4: 컴포넌트 타입/섹션 참조 유효, 이미지 ≤2, 파일명 규칙 → 겹침·zIndex는 이후 단계.
	5.	모델 파라미터(4o)
	•	temperature=0, top_p=1, stop=[“END_S2”,“END_S3”,“END_S4”](해당 단계용), max_tokens 충분히.
	•	한국어 지시 + 예시 포함, “마커 외 텍스트 금지” 2회 반복.
	6.	폴백/보정(coerce)
	•	누락/오류 값은 서버가 안전한 디폴트로 보충.
	•	HEX 소문자/3자리 등은 정규화(#ABC → #AABBCC).

⸻

Step 1 — 기본 정보 및 프로젝트 설정 (현재 구현 분석)

현재 Step1BasicInfo 컴포넌트는 다음을 수행:

1) 자동 저장 시스템 완전 구현
   - initialData → 컴포넌트 상태 동기화 (한 번만 실행)
   - onDataChange로 실시간 데이터 변경 알림 (0.5초 디바운스)
   - 중복 변경 방지를 위한 해시 기반 변경 감지
   - 새로고침 시 데이터 보존 기능

2) UI/UX 특징
   - 3섹션 레이아웃: 기본정보(1/3) + 레이아웃(1/3) + 생성모드(1/3)
   - 가로 스크롤 페이지 구성 카드 (마우스 휠 가로 스크롤 지원)
   - 애니메이션과 스크롤 최적화 (framer-motion)
   - 스크롤형/고정형 레이아웃 선택 (이미지 기반 라디오)
   - AI향상/제한 모드 선택 (contentMode)

3) 데이터 구조 (출력 계약)
   - projectTitle: string (필수)
   - targetAudience: string (필수)
   - pages: PageInfo[] (최소 1개, 동적 추가/제거)
   - layoutMode: 'scrollable' | 'fixed'
   - contentMode: 'enhanced' | 'restricted' (원래 'original' 대신)
   - suggestions: string[] | undefined

4) 검증 및 테스트
   - 필수 필드 검증 (제목, 대상학습자, 최소 1페이지)
   - 테스트 모드 지원 (목업 데이터 자동 입력)
   - 에러 상태 UI 표시

입력 계약 JSON(서버)

{
  "projectData": {
    "id": "project_timestamp",
    "projectTitle": "프로젝트명",
    "targetAudience": "대상 학습자",
    "layoutMode": "scrollable",  // or "fixed"
    "contentMode": "enhanced",   // or "restricted" (현재 구현)
    "pages": [
      {"id":"1","pageNumber":1,"topic":"주제","description":"설명"}
    ],
    "suggestions": ["추가 제안사항"] | undefined,
    "createdAt": "2025-01-01T00:00:00.000Z"
  }
}

개선사항: contentMode 값이 실제 구현과 다름 ('original' → 'restricted')

⸻

Step 2 — 비주얼 아이덴티티 (현재 구현 분석 및 계획)

현재 Step2VisualIdentity 컴포넌트는 다음을 수행:

1) 현재 구현 특징
   - OpenAI GPT-4 기반 비주얼 아이덴티티 생성
   - JSON 구조화된 출력 사용 (Structured Output)
   - 자동 저장 시스템 구현 (onDataChange, 해시 기반 변경 감지)
   - 자동 생성 (Step1에서 진입 시) + 수동 재생성 지원
   - 생성 상태를 부모에게 전달 (onGeneratingChange)

2) 현재 출력 구조 (JSON 기반)
   - visualIdentity.moodAndTone: string[] (4개 형용사)
   - visualIdentity.colorPalette: {primary, secondary, accent, text, background}
   - visualIdentity.typography: {headingFont, bodyFont, baseSize}
   - visualIdentity.componentStyle: string
   - designTokens: 고정 토큰 셋

3) 향후 개선 계획 (라인 기반 포맷으로 전환)

입력:
	•	Step1 JSON(서버가 프롬프트에 그대로 삽입)

프롬프트（gpt‑4o용, 라인 포맷）

[ROLE] 당신은 교육용 VI 전문가입니다.
[CONTEXT] 다음 프로젝트 계약을 참고하세요.
{{S1_JSON}}

[GOAL] 아래 마커 사이에 "라인 기반 K/V"만 출력하세요. 마커 밖 텍스트 금지.
[FORMAT]
- 첫 줄: VERSION=vi.v1
- 다음 줄: MOOD=형용사1,형용사2,형용사3,형용사4   // 쉼표로 4개, 공백 없이
- 다음 줄: COLOR_PRIMARY=#RRGGBB
- 다음 줄: COLOR_SECONDARY=#RRGGBB
- 다음 줄: COLOR_ACCENT=#RRGGBB
- 다음 줄: BASE_SIZE_PT=18  또는 20  // 정수만
- 다음 줄: COMPONENT_STYLE=250자 이내 한국어 설명. 쉼표가 필요하면 전각 쉼표(，)를 사용

[HARD RULES]
- text/background, 폰트는 출력 금지(서버가 고정).
- HEX는 # + 6자리(대소문자 무관).
- BASE_SIZE_PT는 18 또는 20만 허용(고정폭/스크롤 권고에 따름).
- 마커 밖 어떤 문장도 쓰지 마세요.

BEGIN_S2
VERSION=vi.v1
...여기에 결과...
END_S2

서버 수신 포맷(예시)

BEGIN_S2
VERSION=vi.v1
MOOD=명료,친근,탐구,안정
COLOR_PRIMARY=#004D99
COLOR_SECONDARY=#E9F4FF
COLOR_ACCENT=#FFCC00
BASE_SIZE_PT=20
COMPONENT_STYLE=라운드 20–28px와 낮은 그림자，정보를 칩으로 층위화하고 본문 가독성을 우선
END_S2

서버 병합(잠금값 주입)

const BRAND_LOCKS = {
  text: "#0F172A",
  background: "#FFFFFF",
  headingFont: "Pretendard",
  bodyFont: "Noto Sans KR"
};
const TOKENS_FIXED = { /* viewport/safeArea/grid/spacing/radius/elevation/zIndex */ };

function assembleStep2(finalKV, layoutMode){
  return {
    visualIdentity: {
      moodAndTone: finalKV.MOOD.split(','),
      colorPalette: {
        primary: finalKV.COLOR_PRIMARY,
        secondary: finalKV.COLOR_SECONDARY,
        accent: finalKV.COLOR_ACCENT,
        text: BRAND_LOCKS.text,
        background: BRAND_LOCKS.background
      },
      typography: {
        headingFont: BRAND_LOCKS.headingFont,
        bodyFont: BRAND_LOCKS.bodyFont,
        baseSize: `${finalKV.BASE_SIZE_PT}pt`
      },
      componentStyle: finalKV.COMPONENT_STYLE
    },
    designTokens: layoutMode==='fixed'? FIXED_PRESET : SCROLL_PRESET
  };
}

기대 효과
	•	JSON 파싱 불필요(라인 정규식만).
	•	고정 토큰/폰트/텍스트색은 서버 잠금 → 검증 실패 근본 해소.
	•	현재 Structured Output에서 라인 기반으로 전환 시 파싱 안정성 99%+ 달성

⸻

